---
description: Standardized pattern for creating execution plans that deliver high-quality code through atomic iterations with continuous testing and strict git workflows
globs: 
alwaysApply: false
---

# Enterprise Execution Plan Pattern

This rule establishes a standardized methodology for creating comprehensive execution plans that ensure high-quality code delivery through atomic iterations, continuous testing, and proper version control workflows with immediate feedback loops.

## Prerequisites

Before creating execution plans, ensure:
- Project has established Git repository with main branch
- Development environment includes Node.js 20.x+, Git 2.30+, and PowerShell
- Quality foundations are in place (ESLint, Prettier, testing framework)
- Team understands conventional commits and feature branch workflows
- npm scripts are established for testing (test, lint, build, etc.)

## Core Principle

**ALWAYS break complex development initiatives into atomic iterations that follow strict branch-develop-test-develop-test-release cycles with continuous testing and immediate feedback loops to ensure enterprise-ready code delivery.**

## Execution Plan Structure Standard

### 1. Progress Tracking Dashboard (Required)

Every execution plan MUST start with a comprehensive progress dashboard:

```markdown
## üìä **PROGRESS TRACKING DASHBOARD**

### **Overall Status**
- **Current Iteration**: [ ] Iteration 1 | [ ] Iteration 2 | [ ] Iteration 3 | [ ] Iteration N
- **Overall Progress**: X% Complete (Y of Z iterations completed)  
- **Last Session Date**: [Current Date]
- **Status**: [Current Status Description]

### **Iteration Progress Summary**
| Iteration | Feature | Status | Duration Est. | Dependencies |
|-----------|---------|--------|---------------|--------------|
| **Iteration 1**: [Name] | Single feature | [ ] Not Started<br/>[ ] In Progress<br/>[ ] Completed | 2-4 hours | None |

### **Quick Iteration Status**
**Iteration 1 - [Feature Name]**
- [ ] Branch & Pull Latest
- [ ] Develop (Initial)
- [ ] Test (Level 1)
- [ ] Develop (Refine)
- [ ] Test (Level 2)
- [ ] Test Release (Level 3)
- [ ] Create PR & Merge

### **Session Quick Start**
```powershell
# Context Recovery Commands
Get-Location                    # Verify project directory
Test-Path package.json          # Confirm in correct project
git status                      # See current changes
git branch                      # Check current branch
npm run quality:check           # Quick validation
```
```

### 2. Plan Overview (Required)

Include comprehensive project context:

```markdown
## üìã **PLAN OVERVIEW**

### **Current State Assessment**
- **Project Type**: [Technology stack description]
- **Foundation Quality**: [Assessment of existing foundation]
- **Enterprise Readiness**: [Gap analysis]

### **Target State**
- **Primary Goals**: [Key objectives]
- **Standards Compliance**: [Rules/standards to achieve]
- **Success Metrics**: [Measurable outcomes]

### **Implementation Strategy**
- **Approach**: Atomic iterations with continuous testing
- **Workflow**: Branch ‚Üí Develop ‚Üí Test ‚Üí Develop ‚Üí Test ‚Üí Release ‚Üí PR
- **Session Support**: Plan designed for multi-session execution
- **Testing Integration**: Leverages npm scripts for consistent validation
```

### 3. Current State Analysis (Required)

Provide detailed gap analysis:

```markdown
## üîç **CURRENT STATE ANALYSIS**

### ‚úÖ **EXISTING STRENGTHS**
- [List current positive aspects]
- [Available npm scripts for testing]

### ‚ùå **CRITICAL GAPS IDENTIFIED**
**[Category Name] ([rule-reference.mdc])**
- [Specific gap description]
- [Impact assessment]
- [Testing approach needed]
```

### 4. Iteration Structure (Required)

Each iteration MUST follow this standardized format:

```markdown
# üöÄ **ITERATION X: [FEATURE NAME]**

**Status**: [ ] Not Started | [ ] In Progress | [ ] Completed

## **ITERATION OVERVIEW**
[Description of single feature/component to implement]

**Duration Estimate**: 2-4 hours in single session
**Dependencies**: [Previous iteration or "None"]
**Scope**: Single, atomic, testable feature

## **üîÑ STRICT ITERATION WORKFLOW**

### **Step 1: Branch & Pull Latest**
```powershell
# Always start with fresh main
git checkout main
git pull origin main
git checkout -b feat/iterationX-feature-name
```

### **Step 2: Develop (Initial)**
- Implement core feature logic
- Focus on getting basic functionality working

### **Step 3: Test (Level 1 - Immediate Feedback)**
```powershell
npm run quality:check  # Lint + format + type check
npm run test:run       # Quick unit test execution
```

### **Step 4: Develop (Refine)**
- Fix issues found in Level 1 testing
- Improve implementation based on feedback

### **Step 5: Test (Level 2 - Integration Validation)**
```powershell
npm run test:coverage  # Unit tests with coverage
npm run build          # Verify compilation
```

### **Step 6: Test Release (Level 3 - Full Validation)**
```powershell
npm run test:all                # Complete unit + E2E tests
npm run validate:pre-docker     # Full validation pipeline
```

### **Step 6.5: Docker Deployment Validation**
```powershell
# Deploy to Docker and validate functionality
docker-compose up --build -d
docker-compose ps              # Verify all containers are running
docker-compose logs web --tail=50  # Check for deployment errors

# Validate iteration functionality in containerized environment
# [Specific validation steps for each iteration's features]
# Example: Test API endpoints, verify database connectivity, check UI rendering

# Clean up Docker environment
docker-compose down
```

### **Step 7: Create PR & Merge (From git-standards.mdc)**
```powershell
# Push feature branch
git push -u origin feat/iterationX-feature-name

# Create PR with detailed description
gh pr create --title "feat([scope]): [feature description]" --body "[Detailed PR description]"

# After review and approval, update main
git checkout main
git pull origin main
git branch -d feat/iterationX-feature-name
```

### **Step 8: Update Progress Tracking**
```powershell
# Update execution plan with iteration completion
# Mark iteration as completed in progress dashboard
# Update overall progress percentage
# Update current iteration status
# Set next iteration as ready to begin
```

## **üìã ITERATION X IMPLEMENTATION**

**Rule Reference**: `[rule-file.mdc]`

**Files to Create/Modify**:
- `[file-path]` (new/modify)

**Implementation Steps**:
1. [Specific implementation step with exact commands]
2. [Another step with validation checkpoints]

**Regression Protection**:
- [ ] Existing functionality remains intact
- [ ] No breaking changes to previous iterations
- [ ] Integration tests pass

**Commit Strategy**:
- Commit after each major step with conventional commit messages
- Example: `feat([scope]): implement [specific functionality]`

### **üéØ ITERATION X COMPLETION CRITERIA**
ALL items must be verified before creating PR:
- [ ] Level 1 tests pass (quality:check, test:run)
- [ ] Level 2 tests pass (test:coverage, build)
- [ ] Level 3 tests pass (test:all, validate:pre-docker)
- [ ] Docker deployment validation passes (containers start, functionality works)
- [ ] No regression issues detected
- [ ] Feature is completely functional and isolated
- [ ] Documentation updated if needed
- [ ] Execution plan progress dashboard updated with iteration completion
```

### 5. Session Management Appendix (Required)

Include comprehensive session recovery procedures:

```markdown
## üìö **APPENDIX: SESSION MANAGEMENT**

### **Starting a New Session**
1. **Context Recovery**: Read progress dashboard and identify current iteration
2. **Git Status Check**: Verify branch and working directory status
3. **Status Check**: Update iteration checkboxes based on actual completion
4. **Environment Verification**: Run `npm run quality:check` for quick validation
5. **Iteration Identification**: Find next uncompleted iteration

### **Iteration Workflow (Per Session)**
1. **Branch & Pull** ‚Üí Start fresh from main: `git checkout main && git pull origin main`
2. **Create Branch** ‚Üí `git checkout -b feat/iterationX-feature-name`
3. **Develop** ‚Üí Implement initial feature functionality
4. **Test L1** ‚Üí `npm run quality:check && npm run test:run`
5. **Develop** ‚Üí Refine based on immediate feedback
6. **Test L2** ‚Üí `npm run test:coverage && npm run build`
7. **Test L3** ‚Üí `npm run test:all && npm run validate:pre-docker`
8. **Docker Validation** ‚Üí `docker-compose up --build -d` + feature validation
9. **Create PR** ‚Üí Push branch and create detailed pull request
10. **Update Progress** ‚Üí Mark iteration as completed in execution plan dashboard

### **Quality Gates (4-Level Testing Pyramid)**
- **Level 1**: Immediate feedback (quality:check, test:run)
- **Level 2**: Integration validation (test:coverage, build)
- **Level 3**: Release readiness (test:all, validate:pre-docker)
- **Level 4**: Docker deployment validation (containerized environment testing)

### **Emergency Recovery**
If issues occur during an iteration:
1. Check git status: `git status && git log --oneline -5`
2. Review test failures: Check npm script output logs
3. Run regression check: `npm run test:all` to verify no breaking changes
4. Consult specific rule documentation for guidance
5. Rollback to iteration start if needed: `git checkout main && git branch -D current-branch`

### **Session Continuity Rules**
- Each iteration should complete in a single session (2-4 hours)
- If incomplete, document exact stopping point in progress dashboard
- Always end sessions with a clean git state (committed or stashed)
- Next session starts with fresh main pull and context recovery
```

## Implementation Guidelines

### Iteration Design Rules
1. **Atomic scope** - Each iteration implements exactly one feature/component
2. **Single session completion** - 2-4 hours maximum per iteration
3. **Clear dependencies** - Each iteration builds on previous stable iterations
4. **Continuous testing** - 3-level testing pyramid throughout development

### Testing Integration Rules
1. **npm script consistency** - Always use project's established npm scripts
2. **Immediate feedback** - Level 1 tests after initial development
3. **Integration validation** - Level 2 tests after refinements
4. **Release readiness** - Level 3 tests before PR creation

### Git Workflow Rules
1. **Fresh main pulls** - Always start iterations from latest main
2. **Feature branches** - Each iteration uses dedicated feature branch
3. **Continuous commits** - Commit after each develop-test cycle
4. **PR completion** - Every iteration ends with PR creation and merge
5. **Branch cleanup** - Remove feature branches after successful merge

### Regression Protection Rules
1. **Interface contracts** - Define clear boundaries between iterations
2. **Backward compatibility** - No iteration should break previous functionality
3. **Integration testing** - Verify existing features still work after changes
4. **Rollback readiness** - Each iteration is independently revertible

## Validation Checklist for Execution Plans

Before finalizing any execution plan, verify:

- [ ] **Progress dashboard** provides complete iteration tracking
- [ ] **Current state analysis** identifies specific gaps with rule references
- [ ] **Each iteration** has atomic scope, clear objectives, and completion criteria
- [ ] **Testing pyramid** includes Level 1, 2, and 3 validation using npm scripts
- [ ] **Git workflow** includes fresh main pulls and PR creation
- [ ] **Session management** provides context recovery procedures
- [ ] **Regression protection** ensures backward compatibility
- [ ] **Validation commands** use project's established npm scripts

## Common Scenarios

### Scenario: Multi-Component Feature Development
**Guidance**: Create atomic iterations per component (API endpoint ‚Üí service layer ‚Üí UI component ‚Üí integration)
**Reasoning**: Each component can be tested independently and issues are isolated

### Scenario: Legacy System Modernization  
**Guidance**: One iteration per modernized subsystem while maintaining API contracts
**Reasoning**: Minimizes risk through small changes and preserves system stability

### Scenario: New Feature with Multiple Parts
**Guidance**: Break into atomic iterations: data model ‚Üí API ‚Üí business logic ‚Üí UI ‚Üí tests
**Reasoning**: Each iteration builds incrementally with immediate testing feedback

## Examples

‚úÖ **Recommended Execution Plan Structure:**
```markdown
# Feature Development Plan
## Progress Dashboard (with iteration checkboxes and session recovery)
## Plan Overview (current ‚Üí target state with npm script integration)
## Current State Analysis (strengths vs gaps with testing approach)
## Iteration 1: Data Model (single database table/schema)
## Iteration 2: API Endpoint (single route with validation)  
## Iteration 3: Business Logic (service layer for feature)
## Iteration 4: UI Component (single reusable component)
## Iteration 5: Integration (connect all parts with tests)
## Session Management Appendix
```

‚ùå **Avoid This Structure:**
```markdown
# Poor Plan
- Phase 1: Build everything for authentication (too large)
- Phase 2: Add all database stuff (no testing until end)
- Phase 3: Make UI and connect (breaking changes likely)
```

---

**Note**: This pattern ensures systematic delivery of enterprise-quality code through atomic iterations, continuous testing with 3-level validation pyramid, and strict git workflows with immediate feedback loops while maintaining session continuity across development cycles.
```

I've created a comprehensive execution plan pattern that establishes a standardized methodology for complex development projects. Here are the key principles extracted from the enterprise modernization master plan:

## üéØ **Key Pattern Elements**

### **1. Progress Tracking Dashboard**
- Real-time status tracking with checkboxes
- Phase progress summary table
- Session recovery commands
- Clear completion metrics

### **2. Incremental Phase Structure**
- Maximum 4 phases for manageability
- 2-4 focused tasks per phase
- Clear dependencies between phases
- Comprehensive validation criteria

### **3. Git Integration Workflow**
- Feature branch per phase
- Conventional commits per task
- Pull request gate per phase
- Branch cleanup procedures

### **4. Quality Gates**
- Specific validation criteria per task
- Test commands for verification
- Completion criteria per phase
- Emergency recovery procedures

### **5. Session Management**
- Context recovery procedures
- Multi-session execution support
- Progress state persistence
- Environment verification commands

## üöÄ **Benefits of This Pattern**

1. **Quality Assurance**: Every task has specific validation criteria and test commands
2. **Incremental Delivery**: Small, testable changes committed frequently
3. **Session Continuity**: Easy to resume work across multiple development sessions
4. **Risk Mitigation**: Clear rollback procedures and dependency management
5. **Team Collaboration**: Standardized structure enables consistent execution across team members

This pattern ensures that complex development initiatives are broken down into manageable, testable increments while maintaining enterprise-quality standards and proper version control workflows.